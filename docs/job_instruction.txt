
Project: Job Tracker

We are going to build a job tracking application that will be written in ReactJS for the web UI and make calls to a backend API written in Python, which will store and retrieve data from a PostgreSQL database.  


# ReactJS frontend application

The frontend application will be written using ReactJS and should use best practices for ReactJS code that utilizes components and classes as needed and organized into directories.  The application will consist of seven primary pages, each of which will have 1-2 additional pages.  The layout for the application will have a navigation menu located on the left side that is always present, and the main display area taking up the remaining area to the right.  The navigation menu will be comprised of the following entries, each displayed within it's own box with hover changing the look for visual feedback.

    Home
    Job Tracker
    Contacts
    Calendar
    Notes
    Documents
    Resume
    Cover Letter

A note about the navigation menu, so if a job is currently being viewed, the calls made to the API will include the job_id.  This will change the results to be limited to entries associated with that job. If any entry in the menu is clicked and that page is already being displayed, then it drops including the job_id field, which changes the view to be a global scope.  Any duplicate click to the same page being displayed drops holding the job_id field until such a time that another job is the focus.  Don't worry about the home page right now, it can just be left blank for now.


# ===== Job Tracker Page ===============================================================================================

In the main display area for this page, it should have the page title at the top on the left, with a search box justified to the right and a button to it's right the says "+ Add Job".  Below that will be broken into 4 columns that span the total width of the page and at the top of each column will have the title for that column left justified and a total count for the column justified right that will display "xxx Jobs" (with xxx being the total count).  The titles for these 4 columns are: 'Applied', 'Interviewing', 'Rejected' and 'No Response'. In each column there will be summary job cards, which contain minimal job information formatted into three rows as follows:
    Job Title (20% larger than normal font size and left justified)
    Company Name (10% larger than normal font size and left justified)
    calculated date span that is justified to the right
    
The 3rd row calculated date, will determine the date span based on these rules and using the "date_applied" field:
    * if within 13 days of today, it will determine the number of days and display "Added xx days ago"
    * if it falls within 7 weeks of today, it will determine the number of weeks and display "Added xx weeks ago"
    * Everything else will be counted in months, rounding to floor, and display "Added x month ago" (if it's one month) and "Added xx months ago" for any number greater than one.
    
Each of these cards should be selectable and turn on a blue border for on hover. The cards can be dragged and dropped from one column to another, which when done should adjust the total count for the column accordingly. If the card is clicked on, then that will replace the main view area to contain the job details. The search box at the top right, should actively react to each character typed.  As each character is entered, it will match against the company name and hide any cards that don't match.  Cards should collapse upward, taking the place of hidden cards.  Each letter typed will remove more and more cards.  Also, once the search field begins having something typed in it, to the far right of that text area add an X icon, which will be used to clear the search and return the display to it's normal previous state.


# Job Details

The display of the job details marks that a job has been selected as the primary focus, so the job_id should be set and all calls executed by selecting main navigation entries will need to include the job_id in the calls that are done. The job details page will start with a clickable icon of an arrow pointing to the left "<-" and spaced 20px next to that the page name "Job Details", both justified to the left side of the display area and then justified to the right have the buttons "Delete" and "Edit" and a select drop list with options consisting of the job_status values, with the current status pre-selected.  If the arrow icon is clicked on, it will return to the previous page of Job Tracker.  If the "Delete" button is clicked, then the app will make the following call to the API service:

    DELETE /v1/job/<job_id>
    
After which, if successful, it should revert to displaying the previous page.  If the select drop list changes value, the the app will send a job update request to the API using the value from the drop list for the field "job_status".

POST /v1/job
{
    "company": "",
    "job_title": "",
    "salary": "",
    "location": "",
    "interest_level": 1,
    "posting_url": "",
    "apply_url": "",
    "job_desc": "",
    "job_status": "",
    "date_applied": ""
}

Below the top page row, displays all the job details with labels in a blue color font (#0a16ff) and consisting of every field from the job table and presented in an easy to read layout. The job details information can be retrieved by making a call to the API service as follows:
    GET /v1/job/<job_id>

This will return the following payload in the response as application/json format:
{
    "job_id": "",
    "company": "",
    "job_title": "",
    "salary": "",
    "location": "",
    "interest_level": 1,
    "posting_url": "",
    "apply_url": "",
    "job_desc": "",
    "job_status": "",
    "date_applied": ""
    "last_contact": "",
    "resume_id": "",
    "job_created": "",
    "job_directory": ""
}
Don't include the "job_id" or "resume_id" or "cover_id" fields in the display. 

# Add/Edit Job

If the "Edit" button is selected, the main display area should be replaced with a form. This same form will be used for adding a new job when the "+ Add Job" button is selected from the main Job Tracker Page, so it serves a dual purpose for adding and editing jobs. First justified to the left, we have the page title of "Edit Job", which the word "Edit" will need to change to "Add New" when used to add a new job. Below are all the job form fields, which should include the following: 

    company             text field
    job_title           text field
    salary              text field
    location            text field
    interest_level      select drop list (options: 1 - 10)
    posting_url         text field
    apply_url           text field
    job_desc            textarea - this should be large, at least 50 rows
    job_status          select drop list (options: 'applied', 'interviewing', 'rejected', 'no response')
    date_applied        text field with today's date pre-selected and an calendar icon for a calendar popup to select the date
    
    job_id              hidden field
    
Some of the job fields are set automatically, like "job_created", "job_directory", "last_contact", etc - which is why they are excluded from the above description. On form submission, the app will make a call to the API which will handle saving the information to the DB, using the following endpoint:

POST /v1/job
application/json
{
    "job_id": "",
    "company": "",
    "job_title": "",
    "salary": "",
    "location": "",
    "interest_level": 1,
    "posting_url": "",
    "apply_url": "",
    "job_desc": "",
    "job_status": "",
    "date_applied": ""
}

# ===== Contacts =======================================================================================================

The contacts section will have 3 related pages, the first is a spreadsheet like list of all contacts, the second is a detail view for the contact and finally a form page for adding/editing contacts.

The contacts page is displayed when the "Contacts" main navigation menu entry is clicked and will replace the main display area with the following. If a job is currently selected as the focus, the page will start with the same arrow icon used on the Job Details page, which will behave in the same manner and return to the Job Details page if clicked - otherwise the arrow icon is omitted from the display. Following convention, this page starts with the page title of "Contacts" displayed justified to the left and then justified to the right will be a search box with a button to the right of that titled "+ Create Contact" following it. Just below this row will be a spreadsheet like view of all contacts.  To get all the contacts, the app will make a call to the API as:
    GET /v1/contacts
The response from this end point will be in the following format:
[
    {
        "contact_id": "",
        "first_name": "",
        "last_name": "",
        "job_title": "",
        "email": "",
        "phone": "",
        "company": "",
        "linkedin": ""
    }
    ...
]

The search text field should react with each character added, removing the rows that do not match what is being entered.  It should match against the first and last name fields for each contact.  When rows are hidden from view, matching rows should compress upward.  Again, the same as on the Job Tracker page, when the search field has a character entered in, it should display the X icon on the right end of the search text area, which if clicked will clear the search and return the view to display all entries.

Start the first row with a heading for each column with the background blue (#1008ff) and text white.  Then create a row entry for each contact received.  The contact_id won't be displayed, but will need to be identified for the row and for the "linkedin" column, make it an anchor link with only the text "linkedin" showing for the link.  Each row must be selectable and highlight the row on hover.  


# Contact Details

Clicking on any contact row will change the main display area to show the details for that contact.  The contact details page will replace the main display area. Using the same format, we first display the page name of "Contact Details" and optionally if a job is selected, then display the arrow icon to return to the main Contacts page. Justified to the right will be the buttons, "Delete" and "Edit".  The "Delete" button will make the following API call when clicked.
    
    DELETE /v1/contact/<contact_id>
    
If successful, the main display will then return to the main Contacts page. The app will make a call to the API to get the contact detail information to display as follows:

GET /v1/contact/<contact_id>
{
    "contact_id": "",
    "first_name": "",
    "last_name": "",
    "job_title": "",
    "email": "",
    "phone": "",
    "company": "",
    "linkedin": "",
    "contact_note": "",
    "linked_to": [
        {
            "job_id": "",
            "job_title": "",
            "company": ""
        }
        ...
    ]
}

For the field "linked_to", use an anchor link that displays <company> - <job_title> and point the link to load the Job Detail page with that job selected.

# Add/Edit Contact

Clicking on the "Edit" button on the Contact Details page or "+ Create Contact" button on the main Contacts page, will load up the add/edit contact page which will replace the main display area content.  Like the other pages, this starts with the page title of "Edit Contact" - with of course "Edit" being changed to "Add New" if adding a new contact. Below this there is the form to add a new contact with the following fields:

    First Name      text input
    Last_Name       text input
    Job Title       text input
    Email           text input
    Phone number    text input - only allow numbers to be entered and automatically format with dashes for US phone numbers
    Company Name    text input
    Linkedin        text input
    Note            textarea - make it 4 rows in height
 
On submission the app will make a call to the API service as follows, after which it will return to the Contact Details page:
POST /v1/contact
{
    "first_name": "",
    "last_name": "",
    "job_title": "",
    "email": "",
    "phone": "",
    "company": "",
    "linkedin": "",
    "contact_note": ""
}

# ===== Calendar =======================================================================================================

The calendar section consists of 3 page views, the month view, the week view and daily view and additionally will have an appointment details page and an add/edit appointment page, for a total of 5 pages. The calendar page is accessed by clicking on "Calendar" from the main navigation menu and will replace the main display area with it's default view of the current month.

# Month view

The month page starts like the rest, with the page title being "Calendar - month view" and the conditionally displayed arrow icon. Justified to the right is a button titled "+ Add Appointment". Directly below this row should have buttons for navigating through time, so a forward and back arrow button on each end for moving to the next or previous month.  Also have a button labeled "Week", which will switch to the week view calendar. Below the calendar navigation row it will display a grid for the current calendar month.  The current day should be highlighted with the background color of #fbffcd. Use a black color font to number each day of the month and use a light grey for days the bleed into the previous and next months.  The app will make a call to the API service to get scheduled appointments for the month

# ======================================================================================================================

Actually, the new algoritm for finding the diff from the original to rewritten resumes, is more like 20% accurate and not functional enough.  Every word matters and needs to be either matched (in sequence) or flagged as new or removed content.

# ======================================================================================================================

On the View Resume page, let's add another button to the left of the buttons on the top right of the page labeled "Edit".  When this button is clicked on, it will take the user to a new page titled "Manually Edit Resume".  On this page we're going to try something different.  We are going to embed the TinyMCE wysiwyg text editor into the page.  Create a new environment variable named "TINYMCE_API_KEY" and add it to the .env file for use and associate this value to that entry: "7qrgi9by3dbq7a1w58d4mdvcns386w3fmav69z9bnc6yibtd".  The application should make a call to the backend to retrieve the "resume_html_rewrite" value from the "resume_detail" table.  It will then load that content into the embedded editor.  Adjust the editor so that it has a save and cancel button.  The save button will update the same value in the DB from where we grabbed it.  Here's some code that will help you in this task.

Procedure
1. Use the Vite package and the React SWC plugin to create a new React project named tinymce-react-demo.

# NPM 7+, extra double-dash is needed
npm create vite@5 tinymce-react-demo -- --template react-swc

2. Change to the newly created directory.

cd tinymce-react-demo

3. Install the @tinymce/tinymce-react package.

npm install @tinymce/tinymce-react

4. Using a text editor, open ./src/App.jsx and replace the contents with:

import { useRef } from 'react';
import { Editor } from '@tinymce/tinymce-react';
import './App.css';

export default function App() {
  const editorRef = useRef(null);
  const log = () => {
    if (editorRef.current) {
      console.log(editorRef.current.getContent());
    }
  };

  return (
    <>
      <Editor
        apiKey='no-api-key'
        onInit={ (_evt, editor) => editorRef.current = editor }
        initialValue="<p>This is the initial content of the editor.</p>"
        init={{
          height: 500,
          menubar: false,
          plugins: [
            'advlist', 'autolink', 'lists', 'link', 'image', 'charmap', 'preview',
            'anchor', 'searchreplace', 'visualblocks', 'code', 'fullscreen',
            'insertdatetime', 'media', 'table', 'code', 'help', 'wordcount'
          ],
          toolbar: 'undo redo | blocks | ' +
            'bold italic forecolor | alignleft aligncenter ' +
            'alignright alignjustify | bullist numlist outdent indent | ' +
            'removeformat | help',
          content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:14px }'
        }}
      />
      <button onClick={log}>Log editor content</button>
    </>
  );
}
This JavaScript file will create a component “App” containing a TinyMCE editor configured with basic features.

5. Update the apiKey option in the editor element and include your Tiny Cloud API key.

# ======================================================================================================================

So the Optimized Resume page is still missing the majority of differences - matter of fact, I think it's finding even less than before.  Let's change things to work like this:  We can start with sentences, cycling through the original and checking against the rewritten resume, and when the first non-matching sentence is found - then we go into another process.  Break the sentence down into words and now cycle through each word, first against the current rewritten sentence, and then check against the next 2 sentences.  if no match was found, then mark it as removed content.  If a match was found, then we need to see if more matches, so you take the next word from the original and check against the next word from where the match was found in the rewritten.  No match, you stop and move onto the next word.  If a match was found, then keep doing the same until no match was found.  Anything that is matched gets pulled from being checked against again.  This will result in all the removed content

Now do the same thing, only with the rewritten cycled through and checked against the original.  No match, mark it as new and move onto the next word.  If a match was found, find out if more words match in sequence.  Grab the next word from the rewritten and check it against the next word from where the match was found.  No match, then just mark the single word as new content.  No match found, keep adding the next word until no match is found and at that point, mark the match content as new content.

# ======================================================================================================================

You diff utility is still missing like 80% of the differences.  Rather than try to reinvent the wheel, let's use an already established diff utility. Implement the "react-diff-viewer", which is a diff library that also helps out in displaying the diff.

# ======================================================================================================================

Still doesn't have the accuracy wanted.  I did a bit more reasearch and I think this library could be an improvement.  Switch to use this library: react-diff-viewer-continued

# ======================================================================================================================

Let's change the Create Cover Letter page, so when editing the cover letter, it uses the same TinyMCE wysiwyg editor used for editing resumes.

# ======================================================================================================================

Why when adding a new Contact or Editing a Contact, I type in what I want for the Job Title, and it changes it to be "Other".  I want it to save the value that I provided in the form.

# ======================================================================================================================

So what can we do to somehow improve the diff on the resume?  Seems like no matter what is tried, it's a step in a worse direction.  The current implementation of the diff is missing about 95% of the changes.  So what can we do to get this working better?

# ======================================================================================================================

Well, I guess it's a step in the right direction, as it definitely found more differences.  There are a few problems however, the first of which is that if any part of a sentence is different, then the whole sentence is selected. So even if half of the sentence matches, it's all counted as different, when that's not the case.  The display of the differences doesn't render the HTML formatting, which makes it hard to see any styling, as well as hard to read overall - as the HTML tags are mixed in with the content.  This however might be a good starting point to identify differences within a sentence, and then process each sentence to further refine it.

# ======================================================================================================================

Well, sometimes it does well, other times it's half right and then there are times where it's completely wrong.  For example, here's the original:

    | <a href="https://www.davey-walbeck.com/">Website</a></p><h1>Senior Software Architect &amp; Engineering Leader</h1>
And here's the rewritten:
    | <a href="https://www.davey-walbeck.com/">Website</a></p><h1>Senior Software Engineer</h1>
Only the last half was changed, but all of this is selected.

In this one, the original does have a lot of line breaks, which isn't great - especially with the lines so short, which forces the width to be narrow:
    resilient, scalable systems that enhance performance and reduce<br />
    complexity. Deliver efficiency through<strong> clean architecture, </strong>modular<br />
    application programming interfaces<strong> (APIs), </strong>and<strong> open-source<br />
    integration</strong>. Mentor teams, optimize reliability, and <strong>drive<br />
    continuous improvement</strong> in environments where communication,<br />
    creativity, and precision are essential to success.</p>
And now the rewritten version:
     resilient, scalable systems that enhance performance and reduce complexity. Deliver efficiency through <strong>clean architecture, modular application programming interfaces (APIs), and open-source integration</strong>. Mentor teams, optimize reliability, and <strong>drive continuous improvement</strong> in environments where communication, creativity, and precision are essential to success.</p>
Definitely formatted better, but the text is exactly the same.  If it were highlighting the formatting change, then only the break tags should be highlighted.

The rendered view does however make a lot of these things missed much less noticable, and oddly this view is actually more accurate than the source view.  I don't know why that would be, but items that are highlighted incorrectly in the source view, are actually identified and displayed correctly in the rendered view.  There are however some issues, the first being that it smashed the entire page into about 25% of the full width and centered it.  The other issue, which is universally true for all interations using this new library, is that the changed and removed text is not selectable to have it reversed.  This is kind of the whole point of identifying the changes, is so that if they don't want that change, they can revert it back to the original state. 

All-in-all however, the rendered view in this version is the most accurate and best outcome so far.  If the page width is corrected and changes made selectable so that it can be reverted, this may work well enough.


# ======================================================================================================================

When trying to build the frontend application, this error happens:

 => CANCELED [backend 3/8] RUN apt-get update     && apt-get install -y --no-install-recommends         build-essential         libpq-dev         curl         git         pandoc         texlive-latex-base         texlive-latex-recommended         texlive-fonts-recommended         lmodern           15.5s
------
 > [frontend build 6/6] RUN npm run build:
0.590
0.590 > job-tracker-frontend@0.1.0 build
0.590 > react-scripts build
0.590
1.341 [baseline-browser-mapping] The data in this module is over two months old.  To ensure accurate Baseline data, please update: `npm i baseline-browser-mapping@latest -D`
2.154 Creating an optimized production build...
14.03 [baseline-browser-mapping] The data in this module is over two months old.  To ensure accurate Baseline data, please update: `npm i baseline-browser-mapping@latest -D`
15.43 Failed to compile.
15.43
15.43 [eslint]
15.43 src/pages/ViewResume/ViewResume.js
15.43   Line 59:76:  'file_name' is not defined  no-undef
15.43
15.43 Search for the keywords to learn more about each error.
15.43
15.43
------
Dockerfile:15

--------------------

  13 |

  14 |     # Build the app

  15 | >>> RUN npm run build

  16 |

  17 |     # Production stage

--------------------

target frontend: failed to solve: process "/bin/sh -c npm run build" did not complete successfully: exit code: 1

# ======================================================================================================================

For the testing frameworks, I'm not confortable 


# ======================================================================================================================

# ======================================================================================================================

# ======================================================================================================================

# ======================================================================================================================

# ======================================================================================================================





















